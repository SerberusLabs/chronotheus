// main.go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
    "net/url"
    "regexp"
    "sort"
    "strconv"
    "strings"
    "time"
)

// --- ENTRYPOINT --------------------------------------------------------------

func main() {
    proxy := NewChronoProxy()
    log.Println("ðŸŽ‰ Chronotheus proxy starting on :8080 â€¦")
    if err := http.ListenAndServe(":8080", proxy); err != nil {
        log.Fatalf("ðŸ’¥ Server failed: %v", err)
    }
}

// --- PROXY STRUCT & ROUTING -----------------------------------------------

type ChronoProxy struct {
    offsets    []int64
    timeframes []string
    client     *http.Client
}

func NewChronoProxy() *ChronoProxy {
    return &ChronoProxy{
        offsets: []int64{
            0,
            7 * 24 * 3600,
            14 * 24 * 3600,
            21 * 24 * 3600,
            28 * 24 * 3600,
        },
        timeframes: []string{"current", "7days", "14days", "21days", "28days"},
        client:     &http.Client{Timeout: 15 * time.Second},
    }
}

// ServeHTTP dispatches based on the /host_port/â€¦ prefix
func (p *ChronoProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    // parse /<host>_<port>/<suffix>
    re := regexp.MustCompile(`^/([^_/]+)_(\d+)(/.*)?$`)
    m := re.FindStringSubmatch(r.URL.Path)
    if m == nil {
        http.Error(w, `{"status":"error","error":"invalid prefix"}`, 400)
        return
    }
    host, port, suffix := m[1], m[2], m[3]
    if suffix == "" {
        suffix = "/"
    }
    upstream := fmt.Sprintf("http://%s:%s", host, port)

    switch {
    case suffix == "/api/v1/query" && (r.Method == "GET" || r.Method == "POST"):
        p.handleQuery(w, r, upstream, suffix)
    case suffix == "/api/v1/query_range" && (r.Method == "GET" || r.Method == "POST"):
        p.handleQueryRange(w, r, upstream, suffix)
    case suffix == "/api/v1/labels" && (r.Method == "GET" || r.Method == "POST"):
        p.handleLabels(w, r, upstream, suffix)
    case strings.HasPrefix(suffix, "/api/v1/label/") && strings.HasSuffix(suffix, "/values") &&
        (r.Method == "GET" || r.Method == "POST"):
        parts := strings.Split(suffix, "/")
        if len(parts) >= 6 {
            labelName := parts[4]
            p.handleLabelValues(w, r, upstream, suffix, labelName)
        } else {
            http.Error(w, `{"status":"error","error":"invalid label-values path"}`, 400)
        }
    default:
        p.forward(w, r, upstream+suffix)
    }
}

// --- HANDLERS ---------------------------------------------------------------

// handleQuery handles /api/v1/query (instant vector)
func (p *ChronoProxy) handleQuery(w http.ResponseWriter, r *http.Request, upstream, path string) {
    params := parseClientParams(r)

    // detect explicit chrono_timeframe or _command
    requestedTf := ""
    if q := params.Get("query"); q != "" {
        if m := regexp.MustCompile(`\bchrono_timeframe="([^"]+)"`).FindStringSubmatch(q); m != nil {
            requestedTf = m[1]
        }
    }
    command := ""
    if q := params.Get("query"); q != "" {
        if m := regexp.MustCompile(`\b_command="([^"]+)"`).FindStringSubmatch(q); m != nil {
            command = m[1]
        }
    }

    // strip synthetic matchers
    stripLabelFromParam(params, "query", "chrono_timeframe")
    stripLabelFromParam(params, "query", "command")

    // fetch windows
    allSeries := []map[string]interface{}{}
    for i, offset := range p.offsets {
        tfLabel := p.timeframes[i]
        baseTs := parseTime(params.Get("time"))
        params.Set("time", strconv.FormatInt(baseTs-offset, 10))

        urlStr := upstream + path + "?" + buildQueryString(params)
        resp, err := p.client.Get(urlStr)
        if err != nil {
            log.Println("Upstream error:", err)
            http.Error(w, `{"status":"error","error":"upstream failed"}`, 502)
            return
        }
        body, _ := io.ReadAll(resp.Body)
        resp.Body.Close()

        var jr map[string]interface{}
        json.Unmarshal(body, &jr)
        for _, item := range jr["data"].(map[string]interface{})["result"].([]interface{}) {
            series := item.(map[string]interface{})
            pair := series["value"].([]interface{})
            ts := int64(pair[0].(float64))
            val := fmt.Sprintf("%v", pair[1])
            series["value"] = []interface{}{ts + offset, val}

            metric := series["metric"].(map[string]interface{})
            metric["chrono_timeframe"] = tfLabel
            if command != "" {
                metric["_command"] = command
            }
            allSeries = append(allSeries, series)
        }
    }

    // dedupe
    merged := dedupeSeries(allSeries)

    // lastMonthAverage
    avgList := buildLastMonthAverage(merged, false)
    for _, avg := range avgList {
        if command != "" {
            avg["metric"].(map[string]interface{})["_command"] = command
        }
        merged = append(merged, avg)
    }

    // compareAgainstLast28 & percentCompareAgainstLast28
    curBySig, avgBySig := indexBySig(merged, avgList)
    merged = append(merged, buildCompareSeries(curBySig, avgBySig, false, command)...)
    merged = append(merged, buildCompareSeries(curBySig, avgBySig, true, command)...)

    // now filter if requested
    if requestedTf != "" {
        filt := []map[string]interface{}{}
        for _, s := range merged {
            if s["metric"].(map[string]interface{})["chrono_timeframe"] == requestedTf {
                filt = append(filt, s)
            }
        }
        writeJSON(w, "vector", filt)
        return
    }

    writeJSON(w, "vector", merged)
}

// handleQueryRange handles /api/v1/query_range (matrix)
func (p *ChronoProxy) handleQueryRange(w http.ResponseWriter, r *http.Request, upstream, path string) {
    params := parseClientParams(r)

    requestedTf := ""
    if q := params.Get("query"); q != "" {
        if m := regexp.MustCompile(`\bchrono_timeframe="([^"]+)"`).FindStringSubmatch(q); m != nil {
            requestedTf = m[1]
        }
    }
    command := ""
    if q := params.Get("query"); q != "" {
        if m := regexp.MustCompile(`\b_command="([^"]+)"`).FindStringSubmatch(q); m != nil {
            command = m[1]
        }
    }

    stripLabelFromParam(params, "query", "chrono_timeframe")
    stripLabelFromParam(params, "query", "command")

    if params.Get("step") == "" {
        params.Set("step", "60")
    }

    allSeries := []map[string]interface{}{}
    for i, offset := range p.offsets {
        tfLabel := p.timeframes[i]
        start := parseTime(params.Get("start")) - offset
        end := parseTime(params.Get("end")) - offset
        params.Set("start", strconv.FormatInt(start, 10))
        params.Set("end", strconv.FormatInt(end, 10))

        urlStr := upstream + path + "?" + buildQueryString(params)
        resp, err := p.client.Get(urlStr)
        if err != nil {
            log.Println("Upstream error:", err)
            http.Error(w, `{"status":"error","error":"upstream failed"}`, 502)
            return
        }
        body, _ := io.ReadAll(resp.Body)
        resp.Body.Close()

        var jr map[string]interface{}
        json.Unmarshal(body, &jr)
        for _, item := range jr["data"].(map[string]interface{})["result"].([]interface{}) {
            series := item.(map[string]interface{})
            shifted := []interface{}{}
            for _, iv := range series["values"].([]interface{}) {
                pair := iv.([]interface{})
                ts := int64(pair[0].(float64))
                v := fmt.Sprintf("%v", pair[1])
                shifted = append(shifted, []interface{}{ts + offset, v})
            }
            series["values"] = shifted
            metric := series["metric"].(map[string]interface{})
            metric["chrono_timeframe"] = tfLabel
            if command != "" {
                metric["_command"] = command
            }
            allSeries = append(allSeries, series)
        }
    }

    merged := dedupeSeries(allSeries)
    avgList := buildLastMonthAverage(merged, true)
    for _, avg := range avgList {
        if command != "" {
            avg["metric"].(map[string]interface{})["_command"] = command
        }
        merged = append(merged, avg)
    }

    curBySig, avgBySig := indexBySig(merged, avgList)
    merged = append(merged, buildCompareSeries(curBySig, avgBySig, false, command)...)
    merged = append(merged, buildCompareSeries(curBySig, avgBySig, true, command)...)

    if requestedTf != "" {
        filt := []map[string]interface{}{}
        for _, s := range merged {
            if s["metric"].(map[string]interface{})["chrono_timeframe"] == requestedTf {
                filt = append(filt, s)
            }
        }
        writeJSON(w, "matrix", filt)
        return
    }

    writeJSON(w, "matrix", merged)
}

// handleLabels proxies /api/v1/labels
func (p *ChronoProxy) handleLabels(w http.ResponseWriter, r *http.Request, upstream, path string) {
    vals := parseClientParams(r)
    stripLabelFromParam(vals, "match", "chrono_timeframe")
    stripLabelFromParam(vals, "match", "command")
    if lst := vals["match"]; len(lst) > 0 && vals.Get("match[]") == "" {
        vals["match[]"] = lst
        delete(vals, "match")
    }
    urlStr := upstream + path + "?" + buildQueryString(vals)
    resp, err := p.client.Get(urlStr)
    if err != nil {
        http.Error(w, `{"status":"error","error":"upstream failed"}`, 502)
        return
    }
    defer resp.Body.Close()

    var jr map[string]interface{}
    json.NewDecoder(resp.Body).Decode(&jr)

    data, _ := jr["data"].([]interface{})
    if data == nil {
        jr["data"] = []interface{}{}
        jr["status"] = "success"
    } else {
        found := false
        for _, x := range data {
            if x == "chrono_timeframe" {
                found = true
            }
        }
        if !found {
            jr["data"] = append(data, "chrono_timeframe")
        }
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(jr)
}

// handleLabelValues proxies /api/v1/label/{name}/values
func (p *ChronoProxy) handleLabelValues(w http.ResponseWriter, r *http.Request, upstream, path, label string) {
    if label == "chrono_timeframe" {
        resp := map[string]interface{}{
            "status": "success",
            "data":   append(p.timeframes, "lastMonthAverage", "compareAgainstLast28", "percentCompareAgainstLast28"),
        }
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(resp)
        return
    }

    vals := parseClientParams(r)
    stripLabelFromParam(vals, "match", "chrono_timeframe")
    stripLabelFromParam(vals, "match", "command")
    if lst := vals["match"]; len(lst) > 0 && vals.Get("match[]") == "" {
        vals["match[]"] = lst
        delete(vals, "match")
    }
    urlStr := upstream + path + "?" + buildQueryString(vals)
    resp, err := p.client.Get(urlStr)
    if err != nil {
        http.Error(w, `{"status":"error","error":"upstream failed"}`, 502)
        return
    }
    defer resp.Body.Close()
    w.Header().Set("Content-Type", "application/json")
    io.Copy(w, resp.Body)
}

// forward proxies any other path unchanged
func (p *ChronoProxy) forward(w http.ResponseWriter, r *http.Request, urlStr string) {
    var req *http.Request
    var err error
    if r.Method == "GET" {
        req, err = http.NewRequest("GET", urlStr+"?"+r.URL.RawQuery, nil)
    } else {
        body, _ := io.ReadAll(r.Body)
        req, err = http.NewRequest(r.Method, urlStr, bytes.NewReader(body))
    }
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    for k, v := range r.Header {
        req.Header[k] = v
    }
    resp, err := p.client.Do(req)
    if err != nil {
        http.Error(w, err.Error(), 502)
        return
    }
    defer resp.Body.Close()
    for k, v := range resp.Header {
        w.Header()[k] = v
    }
    w.WriteHeader(resp.StatusCode)
    io.Copy(w, resp.Body)
}

// --- UTILITIES -------------------------------------------------------------

// parseClientParams merges GET + POST (JSON or form) into url.Values
func parseClientParams(r *http.Request) url.Values {
    vals := url.Values{}

    if r.Method == "POST" {
        ct := r.Header.Get("Content-Type")
        body, _ := io.ReadAll(r.Body)
        if strings.Contains(ct, "application/json") {
            var m map[string]interface{}
            json.Unmarshal(body, &m)
            for k, v := range m {
                switch vv := v.(type) {
                case []interface{}:
                    for _, x := range vv {
                        vals.Add(k, fmt.Sprintf("%v", x))
                    }
                default:
                    vals.Set(k, fmt.Sprintf("%v", vv))
                }
            }
        } else {
            r.Body = io.NopCloser(bytes.NewReader(body))
            r.ParseForm()
            for k, vs := range r.PostForm {
                for _, x := range vs {
                    vals.Add(k, x)
                }
            }
        }
    }

    for k, vs := range r.URL.Query() {
        for _, x := range vs {
            vals.Add(k, x)
        }
    }
    return vals
}

// stripLabelFromParam removes any ,?label="value" and cleans commas
func stripLabelFromParam(vals url.Values, key, label string) {
    re := regexp.MustCompile(`,?` + regexp.QuoteMeta(label) + `="[^"]*"`)
    if vs, ok := vals[key]; ok {
        for i, s := range vs {
            s = re.ReplaceAllString(s, "")
            s = regexp.MustCompile(`,+`).ReplaceAllString(s, ",")
            s = regexp.MustCompile(`\{\s*,+`).ReplaceAllString(s, "{")
            s = regexp.MustCompile(`,+\s*\}`).ReplaceAllString(s, "}")
            vs[i] = s
        }
        vals[key] = vs
    }
}

// buildQueryString serializes url.Values preserving [] syntax
func buildQueryString(vals url.Values) string {
    parts := []string{}
    for k, vs := range vals {
        name := k
        if len(vs) > 1 && !strings.HasSuffix(k, "[]") {
            name = k + "[]"
        }
        for _, v := range vs {
            parts = append(parts, url.QueryEscape(name)+"="+url.QueryEscape(v))
        }
    }
    return strings.Join(parts, "&")
}

// parseTime handles integer or RFC3339
func parseTime(tsStr string) int64 {
    if i, err := strconv.ParseInt(tsStr, 10, 64); err == nil {
        return i
    }
    if t, err := time.Parse(time.RFC3339, tsStr); err == nil {
        return t.Unix()
    }
    return time.Now().Unix()
}

// signature returns a stable JSON signature minus synthetic labels
func signature(m map[string]interface{}) string {
    cp := copyMetric(m)
    delete(cp, "chrono_timeframe")
    delete(cp, "_command")
    keys := make([]string, 0, len(cp))
    for k := range cp {
        keys = append(keys, k)
    }
    sort.Strings(keys)
    ordered := map[string]interface{}{}
    for _, k := range keys {
        ordered[k] = cp[k]
    }
    b, _ := json.Marshal(ordered)
    return string(b)
}

// dedupeSeries groups by signature then flattens
func dedupeSeries(all []map[string]interface{}) []map[string]interface{} {
    bySig := map[string][]map[string]interface{}{}
    for _, s := range all {
        sig := signature(s["metric"].(map[string]interface{}))
        bySig[sig] = append(bySig[sig], s)
    }
    out := []map[string]interface{}{}
    for _, grp := range bySig {
        out = append(out, grp...)
    }
    return out
}

// buildLastMonthAverage builds one avg-series per signature
func buildLastMonthAverage(seriesList []map[string]interface{}, isRange bool) []map[string]interface{} {
    numHist := 4 // always 4 historical slices
    groups := map[string][]map[string]interface{}{}
    for _, s := range seriesList {
        m := s["metric"].(map[string]interface{})
        if m["chrono_timeframe"] == "current" {
            continue
        }
        base := copyMetric(m)
        delete(base, "chrono_timeframe")
        delete(base, "_command")
        sig := signature(base)
        groups[sig] = append(groups[sig], s)
    }
    out := []map[string]interface{}{}
    for sig, grp := range groups {
        sums := map[int64]float64{}
        for _, s := range grp {
            pts := []interface{}{}
            if isRange {
                pts = s["values"].([]interface{})
            } else {
                pts = []interface{}{s["value"]}
            }
            for _, iv := range pts {
                pair := iv.([]interface{})
                ts := int64(pair[0].(float64))
                v, _ := strconv.ParseFloat(fmt.Sprintf("%v", pair[1]), 64)
                min := (ts / 60) * 60
                sums[min] += v
            }
        }
        mins := make([]int64, 0, len(sums))
        for m := range sums {
            mins = append(mins, m)
        }
        sort.Slice(mins, func(i, j int) bool { return mins[i] < mins[j] })
        ptsOut := []interface{}{}
        for _, m := range mins {
            avg := sums[m] / float64(numHist)
            ptsOut = append(ptsOut, []interface{}{m, fmt.Sprintf("%g", avg)})
        }
        metric := map[string]interface{}{}
        json.Unmarshal([]byte(sig), &metric)
        metric["chrono_timeframe"] = "lastMonthAverage"
        if isRange {
            out = append(out, map[string]interface{}{
                "metric": metric,
                "values": ptsOut,
            })
        } else {
            last := ptsOut[len(ptsOut)-1].([]interface{})
            out = append(out, map[string]interface{}{
                "metric": metric,
                "value":  last,
            })
        }
    }
    return out
}

// indexBySig returns maps of current and average series by signature
func indexBySig(all, avgList []map[string]interface{}) (
    map[string]map[string]interface{},
    map[string]map[string]interface{},
) {
    curBy := map[string]map[string]interface{}{}
    avgBy := map[string]map[string]interface{}{}
    for _, s := range all {
        m := s["metric"].(map[string]interface{})
        if m["chrono_timeframe"] == "current" {
            curBy[signature(m)] = s
        }
    }
    for _, a := range avgList {
        m := a["metric"].(map[string]interface{})
        avgBy[signature(m)] = a
    }
    return curBy, avgBy
}

// buildCompareSeries builds raw or percent diffs
func buildCompareSeries(curBy, avgBy map[string]map[string]interface{}, percent bool, command string) []map[string]interface{} {
    out := []map[string]interface{}{}
    for sig, cur := range curBy {
        avg, ok := avgBy[sig]
        if !ok {
            continue
        }
        mCur := cur["metric"].(map[string]interface{})
        newM := copyMetric(mCur)
        if percent {
            newM["chrono_timeframe"] = "percentCompareAgainstLast28"
        } else {
            newM["chrono_timeframe"] = "compareAgainstLast28"
        }
        if command != "" {
            newM["_command"] = command
        }
        // extract numbers
        var baseMap map[int64]float64
        vals := []interface{}{}
        if percent {
            // percent: work off avgBy series values
            baseMap = map[int64]float64{}
            for _, iv := range avg["values"].([]interface{}) {
                pair := iv.([]interface{})
                baseMap[int64(pair[0].(float64))] = pair[1].(float64)
            }
            for _, iv := range cur["values"].([]interface{}) {
                pair := iv.([]interface{})
                ts := int64(pair[0].(float64))
                v, _ := strconv.ParseFloat(fmt.Sprintf("%v", pair[1]), 64)
                if avgV, ok := baseMap[ts]; ok && avgV != 0 {
                    pct := (v-avgV)/avgV*100
                    vals = append(vals, []interface{}{ts, fmt.Sprintf("%g", pct)})
                }
            }
        } else {
            // raw diff
            pairC := cur["value"].([]interface{})
            ts := pairC[0].(int64)
            vc, _ := strconv.ParseFloat(fmt.Sprintf("%v", pairC[1]), 64)
            pairA := avg["value"].([]interface{})
            va, _ := strconv.ParseFloat(fmt.Sprintf("%v", pairA[1]), 64)
            diff := vc - va
            vals = append(vals, []interface{}{ts, fmt.Sprintf("%g", diff)})
        }
        if percent {
            out = append(out, map[string]interface{}{
                "metric": newM,
                "values": vals,
            })
        } else {
            out = append(out, map[string]interface{}{
                "metric": newM,
                "value":  vals[0],
            })
        }
    }
    return out
}

// copyMetric makes a shallow copy of a metric map
func copyMetric(m map[string]interface{}) map[string]interface{} {
    c := map[string]interface{}{}
    for k, v := range m {
        c[k] = v
    }
    return c
}

// writeJSON writes the final envelope for vector or matrix
func writeJSON(w http.ResponseWriter, resultType string, result []map[string]interface{}) {
    w.Header().Set("Content-Type", "application/json")
    out := map[string]interface{}{
        "status": "success",
        "data": map[string]interface{}{
            "resultType": resultType,
            "result":     result,
        },
    }
    json.NewEncoder(w).Encode(out)
}
